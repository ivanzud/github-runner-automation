#!/bin/bash

# Auto-register GitHub Runners for repositories with self-hosted configurations
# PRODUCTION VERSION - Uses production settings

set -e

# Production Configuration (from vault file)
GITHUB_TOKEN="{{ github_token }}"
GITHUB_USERNAME="{{ github_username }}"
RUNNER_LABELS="{{ runner_labels }}"
RUNNER_NAME_PREFIX="{{ runner_name_prefix }}"
RUNNER_WORK_DIR="{{ runner_work_dir }}"
RUNNER_USER="{{ runner_user }}"
LOG_FILE="{{ log_file }}"
MAX_PARALLEL_JOBS={{ max_parallel_jobs }}
RUNNER_CLEANUP_DAYS={{ runner_cleanup_days }}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function - redirect to stderr to avoid interfering with command substitution
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$LOG_FILE" >&2
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING:${NC} $1" | tee -a "$LOG_FILE" >&2
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR:${NC} $1" | tee -a "$LOG_FILE" >&2
}

# Remove old job workspaces to control disk usage.
cleanup_old_workspaces() {
    if ! echo "$RUNNER_CLEANUP_DAYS" | grep -Eq '^[0-9]+$'; then
        warn "RUNNER_CLEANUP_DAYS is not a valid number: '$RUNNER_CLEANUP_DAYS' (skipping cleanup)"
        return 0
    fi

    if [ "$RUNNER_CLEANUP_DAYS" -le 0 ]; then
        log "Workspace cleanup disabled (RUNNER_CLEANUP_DAYS=$RUNNER_CLEANUP_DAYS)"
        return 0
    fi

    log "Cleaning runner workspaces older than ${RUNNER_CLEANUP_DAYS} days..."

    find "$RUNNER_WORK_DIR" -type d -name _work -print0 2>/dev/null | while IFS= read -r -d '' work_dir; do
        find "$work_dir" -mindepth 1 -maxdepth 1 -mtime +"$RUNNER_CLEANUP_DAYS" -print0 2>/dev/null \
            | while IFS= read -r -d '' path; do
                rm -rf "$path"
            done
    done
}
# Build a runner name that conforms to GitHub limits and character rules.
build_runner_name() {
    local repo="$1"
    local max_len=63
    local prefix
    local repo_slug
    local host
    local base
    local len

    prefix=$(echo "$RUNNER_NAME_PREFIX" | tr -cd '[:alnum:]-')
    if [ -z "$prefix" ]; then
        prefix="runner"
    fi

    repo_slug=$(echo "$repo" | tr '/.' '-' | tr -cd '[:alnum:]-')
    host=$(hostname | tr -cd '[:alnum:]-')

    base="${prefix}-${repo_slug}-${host}"
    len=$(printf '%s' "$base" | wc -c | tr -d ' ')
    if [ "$len" -le "$max_len" ]; then
        printf '%s' "$base"
        return 0
    fi

    local repo_hash
    repo_hash=$(echo "$repo" | md5sum | cut -c1-8)
    base="${prefix}-${repo_hash}-${host}"
    len=$(printf '%s' "$base" | wc -c | tr -d ' ')
    if [ "$len" -le "$max_len" ]; then
        printf '%s' "$base"
        return 0
    fi

    base="${prefix}-${repo_hash}"
    printf '%s' "$base" | cut -c1-"$max_len"
}

# Check if required tools are installed
check_dependencies() {
    log "Checking dependencies..."
    
    if ! command -v jq &> /dev/null; then
        error "jq is required but not installed. Please install it first."
        exit 1
    fi
    
    if ! command -v curl &> /dev/null; then
        error "curl is required but not installed. Please install it first."
        exit 1
    fi
    
    if ! command -v git &> /dev/null; then
        error "git is required but not installed. Please install it first."
        exit 1
    fi
    
    log "All dependencies are installed."
}

# Check if GitHub token is valid
check_github_token() {
    log "Validating GitHub token..."
    
    if [ -z "$GITHUB_TOKEN" ]; then
        error "GITHUB_TOKEN environment variable is not set."
        exit 1
    fi
    
    # Test the token by making a request to GitHub API
    {% raw %}
    local http_code=$(curl -s -o /tmp/github_response.json -w "%{http_code}" -H "Authorization: token $GITHUB_TOKEN" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/user")
    {% endraw %}
    
    local body=$(cat /tmp/github_response.json 2>/dev/null || echo "")
    rm -f /tmp/github_response.json
    
    if [ "$http_code" = "200" ] && echo "$body" | jq -e '.login' > /dev/null 2>&1; then
        local username=$(echo "$body" | jq -r '.login')
        log "GitHub token is valid. Authenticated as: $username"
        GITHUB_USERNAME="$username"
    else
        error "Invalid GitHub token. HTTP Code: $http_code"
        if [ -n "$body" ]; then
            error "API Response: $body"
        fi
        exit 1
    fi
}

# Get list of repositories that need runners (optimized with parallel processing)
get_repositories_needing_runners() {
    log "Fetching repositories that need runners (parallel processing)..."
    
    local repos=()
    local page=1
    local per_page=100
    
    # First, get all repositories
    local all_repos=()
    while true; do
        local response=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/user/repos?page=$page&per_page=$per_page&type=owner")
        
        local repos_in_page=$(echo "$response" | jq -r '.[] | select(.fork == false) | .full_name')
        
        if [ -z "$repos_in_page" ]; then
            break
        fi
        
        while IFS= read -r repo; do
            if [ -n "$repo" ]; then
                all_repos+=("$repo")
            fi
        done <<< "$repos_in_page"
        
        page=$((page + 1))
    done
    
    {% raw %}
    log "Found ${#all_repos[@]} total repositories, checking for self-hosted runners..."
    {% endraw %}
    
    # Process repositories in parallel to check for self-hosted runners
    local temp_dir=$(mktemp -d)
    local pids=()
    local counter=0
    
    for repo in "${all_repos[@]}"; do
        # Limit parallel jobs
        {% raw %}
        if [ ${#pids[@]} -ge $MAX_PARALLEL_JOBS ]; then
        {% endraw %}
            # Wait for one job to complete
            for i in "${!pids[@]}"; do
                if ! kill -0 "${pids[$i]}" 2>/dev/null; then
                    unset "pids[$i]"
                    break
                fi
            done
            # Rebuild array
            pids=("${pids[@]}")
        fi
        
        # Start parallel check
        (
            if repository_needs_runner "$repo"; then
                echo "$repo" > "$temp_dir/repo_$counter"
                log "Repository $repo needs a runner"
            fi
        ) &
        pids+=($!)
        counter=$((counter + 1))
    done
    
    # Wait for all remaining jobs
    for pid in "${pids[@]}"; do
        if ! wait "$pid"; then
            warn "Repository scan process $pid failed"
        fi
    done
    
    # Collect results
    for file in "$temp_dir"/repo_*; do
        if [ -f "$file" ]; then
            repos+=("$(cat "$file")")
        fi
    done
    
    rm -rf "$temp_dir"
    
    # Return repositories as space-separated string
    printf '%s\n' "${repos[@]}"
}

# Check if a repository needs a runner (optimized)
repository_needs_runner() {
    local repo="$1"
    
    # Check if repository has .github/workflows directory with self-hosted runner configurations
    local response=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/repos/$repo/contents/.github/workflows")
    local response_type=$(echo "$response" | jq -r 'type' 2>/dev/null || echo "unknown")
    if [ "$response_type" = "array" ]; then
        # Check each workflow file for self-hosted runner usage
        local workflows=$(echo "$response" | jq -r '.[] | select(.name | endswith(".yml")) | .name')
        
        while IFS= read -r workflow; do
            if [ -n "$workflow" ]; then
                local workflow_content=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
                    -H "Accept: application/vnd.github.v3+json" \
                    "https://api.github.com/repos/$repo/contents/.github/workflows/$workflow")
                local content=$(echo "$workflow_content" | jq -r '.content // empty' 2>/dev/null | base64 -d)
                if [ -z "$content" ]; then
                    local message=$(echo "$workflow_content" | jq -r '.message // empty' 2>/dev/null)
                    warn "Skipping workflow '$workflow' for $repo (missing content). ${message:+API message: $message}"
                    continue
                fi
                
                # Check for any runs-on value (ubuntu-latest, self-hosted, or any other runner)
                if echo "$content" | grep -qE "runs-on:\s*(\[.*\]|.+)"; then
                    return 0  # Repository needs a runner
                fi
            fi
        done <<< "$workflows"
    else
        local message=$(echo "$response" | jq -r '.message // empty' 2>/dev/null)
        warn "Skipping workflows for $repo (unexpected response type: $response_type). ${message:+API message: $message}"
    fi
    
    return 1  # Repository doesn't need a runner
}

# Check if a runner is already registered for a repository
runner_exists() {
    local repo="$1"
    local runner_name="$2"
    
    local response=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/repos/$repo/actions/runners")
    
    if echo "$response" | jq -e '.runners' > /dev/null 2>&1; then
        local existing_runners=$(echo "$response" | jq -r '.runners[].name')
        
        while IFS= read -r existing_runner; do
            if [ "$existing_runner" = "$runner_name" ]; then
                return 0  # Runner exists
            fi
        done <<< "$existing_runners"
    fi
    
    return 1  # Runner doesn't exist
}

# Register a runner for a repository (optimized)
register_runner() {
    local repo="$1"
    local runner_name="$2"
    
    log "Registering runner '$runner_name' for repository '$repo'..."
    
    # Create runner directory
    local runner_dir="$RUNNER_WORK_DIR/$repo/$runner_name"
    mkdir -p "$runner_dir"
    chown -R "$RUNNER_USER:$RUNNER_USER" "$runner_dir"
    
    # Download the latest runner
    cd "$runner_dir"
    
    if [ ! -f "actions-runner-linux-x64.tar.gz" ]; then
        log "Downloading latest GitHub Actions runner..."
        curl -o actions-runner-linux-x64.tar.gz -L https://github.com/actions/runner/releases/download/v2.311.0/actions-runner-linux-x64-2.311.0.tar.gz
        chown "$RUNNER_USER:$RUNNER_USER" actions-runner-linux-x64.tar.gz
    fi
    
    # Extract runner
    if [ ! -d "bin" ]; then
        log "Extracting runner..."
        tar xzf actions-runner-linux-x64.tar.gz
        chown -R "$RUNNER_USER:$RUNNER_USER" .
    fi
    
    # Get registration token
    local token_response=$(curl -s -o /tmp/runner_token.json -w "%{http_code}" -X POST \
        -H "Authorization: token $GITHUB_TOKEN" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/repos/$repo/actions/runners/registration-token")
    local http_code="$token_response"
    local registration_token=$(jq -r '.token // empty' /tmp/runner_token.json 2>/dev/null)
    local token_message=$(jq -r '.message // empty' /tmp/runner_token.json 2>/dev/null)
    rm -f /tmp/runner_token.json
    
    if [ "$registration_token" = "null" ] || [ -z "$registration_token" ]; then
        error "Failed to get registration token for $repo (HTTP $http_code). ${token_message:+API message: $token_message}"
        return 1
    fi
    
    # Configure and start the runner as the runner user
    log "Configuring runner..."
    sudo -u "$RUNNER_USER" ./config.sh \
        --url "https://github.com/$repo" \
        --token "$registration_token" \
        --name "$runner_name" \
        --labels "$RUNNER_LABELS" \
        --unattended \
        --replace
    
    # Create systemd service
    create_systemd_service "$repo" "$runner_name" "$runner_dir"
    
    # Start the service
    local repo_hash=$(echo "$repo" | md5sum | cut -c1-8)
    systemctl enable "github-runner@${repo_hash}"
    systemctl start "github-runner@${repo_hash}"
    
    log "Runner '$runner_name' successfully registered for repository '$repo'"
}

# Create systemd service for the runner
create_systemd_service() {
    local repo="$1"
    local runner_name="$2"
    local runner_dir="$3"
    # Create a shorter service name using hash of repo name
    local repo_hash=$(echo "$repo" | md5sum | cut -c1-8)
    local service_name="github-runner@${repo_hash}"
    
    cat > "/etc/systemd/system/$service_name.service" << EOF
[Unit]
Description=GitHub Actions Runner for $repo
After=network.target

[Service]
Type=simple
User=$RUNNER_USER
WorkingDirectory=$runner_dir
ExecStart=$runner_dir/run.sh
Restart=always
RestartSec=10
Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

[Install]
WantedBy=multi-user.target
EOF
    
    systemctl daemon-reload
}

# Process a single repository (for parallel execution)
process_repository() {
    local repo="$1"
    local runner_name
    runner_name=$(build_runner_name "$repo")
    
    if runner_exists "$repo" "$runner_name"; then
        log "Runner '$runner_name' already exists for repository '$repo'"
    else
        if register_runner "$repo" "$runner_name"; then
            log "Successfully registered runner for $repo"
        else
            error "Failed to register runner for $repo"
        fi
    fi
}

# Main function
main() {
    log "Starting automated GitHub runner registration (production version)..."
    
    check_dependencies
    check_github_token
    
    # Create runner user if it doesn't exist
    if ! id "$RUNNER_USER" &>/dev/null; then
        log "Creating runner user: $RUNNER_USER"
        useradd -r -s /bin/bash -d /home/$RUNNER_USER -m $RUNNER_USER
    fi
    
    # Create work directory
    mkdir -p "$RUNNER_WORK_DIR"
    chown -R "$RUNNER_USER:$RUNNER_USER" "$RUNNER_WORK_DIR"
    
    # Get repositories that need runners
    local repos=($(get_repositories_needing_runners))
    
    {% raw %}
    if [ ${#repos[@]} -eq 0 ]; then
    {% endraw %}
        log "No repositories found that need runners."
        return 0
    fi
    
    {% raw %}
    log "Found ${#repos[@]} repositories that need runners: ${repos[*]}"
    {% endraw %}
    
    # Process repositories in parallel
    local pids=()
    for repo in "${repos[@]}"; do
        # Limit parallel jobs
        {% raw %}
        if [ ${#pids[@]} -ge $MAX_PARALLEL_JOBS ]; then
        {% endraw %}
            # Wait for one job to complete
            for i in "${!pids[@]}"; do
                if ! kill -0 "${pids[$i]}" 2>/dev/null; then
                    unset "pids[$i]"
                    break
                fi
            done
            # Rebuild array
            pids=("${pids[@]}")
        fi
        
        # Start parallel processing
        process_repository "$repo" &
        pids+=($!)
    done
    
    # Wait for all remaining jobs
    local failures=0
    for pid in "${pids[@]}"; do
        if ! wait "$pid"; then
            failures=$((failures + 1))
        fi
    done

    if [ "$failures" -gt 0 ]; then
        warn "Completed with $failures failed runner registrations"
    fi
    
    log "Automated runner registration completed (production version)."

    cleanup_old_workspaces
}

# Run main function
main "$@" 
